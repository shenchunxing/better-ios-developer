[理解队列、任务、线程之间的关系](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#理解队列和任务以及线程之间的关系) 

 [GCD的队列（dispatch_queue_t）分哪两种类型？](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#gcd的队列dispatch_queue_t分哪两种类型) 
 
 [如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图) 
 
 [dispatch_barrier_async的作用是什么？](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#dispatch_barrier_async的作用是什么) 
 
 [苹果为什么要废弃dispatch_get_current_queue？](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#苹果为什么要废弃dispatch_get_current_queue) 
 
 [以下代码运行结果如何？](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md#以下代码运行结果如何) 
 
 [@synchronized总结](https://github.com/shenchunxing/ios_interview_questions/blob/master/多线程/多线程.md# @synchronized总结) 
 


 ```Objective-C
- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
 ```
 
### 理解队列和任务以及线程之间的关系

假设现在有 5 个人要穿过一道门禁，这道门禁总共有 10 个入口，管理员可以决定同一时间打开几个入口，可以决定同一时间让一个人单独通过还是多个人一起通过。不过默认情况下，管理员只开启一个入口，且一个通道一次只能通过一个人。


这个故事里，人好比是 任务，管理员好比是 系统，入口则代表 线程。

5 个人表示有 5 个任务，10 个入口代表 10 条线程。
串行队列 好比是 5 个人排成一支长队。
并发队列 好比是 5 个人排成多支队伍，比如 2 队，或者 3 队。
同步任务 好比是管理员只开启了一个入口（当前线程）。
异步任务 好比是管理员同时开启了多个入口（当前线程 + 新开的线程）。



『异步执行 + 并发队列』 可以理解为：现在管理员开启了多个入口（比如 3 个入口），5 个人排成了多支队伍（比如 3 支队伍），这样这 5 个人就可以 3 个人同时一起穿过门禁了。


『同步执行 + 并发队列』 可以理解为：现在管理员只开启了 1 个入口，5  个人排成了多支队伍。虽然这 5 个人排成了多支队伍，但是只开了 1 个入口啊，这 5 个人虽然都想快点过去，但是 1 个入口一次只能过 1 个人，所以大家就只好一个接一个走过去了，表现的结果就是：顺次通过入口。


换成 GCD 里的语言就是说：

『异步执行 + 并发队列』就是：系统开启了多个线程（主线程+其他子线程），任务可以多个同时运行。
『同步执行 + 并发队列』就是：系统只默认开启了一个主线程，没有开启子线程，虽然任务处于并发队列中，但也只能一个接一个执行了。


### GCD的队列（`dispatch_queue_t`）分哪两种类型？


 1. 串行队列Serial Dispatch Queue
 2. 并发队列Concurrent Dispatch Queue

### 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）

使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。

```Objective-C
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});
```
### `dispatch_barrier_async`的作用是什么？
 在并发队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 
 `dispatch_barrier_async` 函数会等待追加到Concurrent Dispatch Queue并发队列中的操作全部执行完之后，然后再执行 `dispatch_barrier_async` 函数追加的处理，等 `dispatch_barrier_async` 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。

打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 `dispatch_barrier_async` 函数追加的内容就如同 “上完厕所就上高速”这个动作。

（注意：使用 `dispatch_barrier_async` ，该函数只能搭配自定义并发队列 `dispatch_queue_t` 使用。不能使用： `dispatch_get_global_queue` ，否则 `dispatch_barrier_async` 的作用会和 `dispatch_async` 的作用一模一样。 ）


### 苹果为什么要废弃`dispatch_get_current_queue`？

`dispatch_get_current_queue`函数的行为常常与开发者所预期的不同。
由于派发队列是按层级来组织的，这意味着排在某条队列中的块会在其上级队列里执行。
队列间的层级关系会导致检查当前队列是否为执行同步派发所用的队列这种方法并不总是奏效。`dispatch_get_current_queue`函数通常会被用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用"队列特定数据"来解决。

### 以下代码运行结果如何？



 ```Objective-C
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSLog(@"1");
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSLog(@"2");
        });
        NSLog(@"3");
    }
 ```


只输出：1 。发生主线程锁死。


### @synchronized总结

objc_sync_exit流程和objc_sync_enter流程走的是一样的只不过一个是加锁一个是解锁

@synchronized底层是链表查找、缓存查找以及递归，是非常耗内存以及性能的

@synchronized底层封装了是一把递归锁，可以自动进行加锁解锁，这也是大家喜欢使用它的原因

@synchronized中lockCount控制递归，而threadCount控制多线程

@synchronized加锁的对象尽量不要为nil，不然起不到加锁的效果

