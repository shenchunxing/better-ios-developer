
二、可选链（Optional Chaining）
========================

看下面的示例代码:

```
class Person {
     var name: String = ""
     var dog: Dog = Dog()
     var car: Car? = Car()
      
     func age() -> Int { 18 }
      
     func eat() {
     print("Person eat")
     }
      
     subscript(index: Int) -> Int { index }
}
```

*   1.  如果可选项为`nil`，调用方法、下标、属性失败，结果为`nil`
    
    ```
    var person: Person? = nil
    var age = person?.age()
    var name = person?.name
    var index = person?[6]
    print(age, name, index) // nil, nil, nil
    ```
    
    ```
    // 如果person为nil，都不会调用getName
    func getName() -> String { "jack" }
    var person: Person? = nil
    person?.name = getName()
    ```
    
*   2.  如果可选项不为`nil`，调用`方法`、`下标`、`属性`成功，结果会被包装成`可选项`
    
   ```
    var person: Person? = Person()
    var age = person?.age()
    var name = person?.name
    var index = person?[6]
    print(age, name, index) // Optional(18) Optional("") Optional(6)
    ```
    
*   3.  如果结果`本来就是可选项`，不会进行再次包装
    
    ```
    print(person?.car) // Optional(test_enum.Car)
    ```
    
*   4.  可以用可选绑定来判断可选项的方法调用是否成功
    
    swift
    
    复制代码
    
    `let result: ()? = person?.eat()
    if let _ = result {
     print("调用成功")
    } else {
     print("调用失败")
    }` 
    
    swift
    
    复制代码
    
    `if let age = person?.age() {
     print("调用成功", age)
    } else {
     print("调用失败")
    }` 
    
*   5.  没有设定返回值的方法默认返回的就是`元组类型` ![-w521](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8b75b19c58c4059a2380e609ddb9540~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   6.  多个?可以连接在一起，组成可选链
    
    swift
    
    复制代码
    
    `var dog = person?.dog
    var weight = person?.dog.weight
    var price = person?.car?.price` 
    
*   7.  可选链中不管中间经历多少层，只要有一个节点是可选项的，那么最后的结果就是会被包装成可选项的
    
    swift
    
    复制代码
    
    `print(dog, weight, price) // Optional(test_enum.Dog) Optional(0) Optional(0)` 
    
*   8.  如果链中任何一个节点是`nil`，那么整个链就会调用失败  
        看下面示例代码
    
    swift
    
    复制代码
    
    `var num1: Int? = 5
    num1? = 10
    print(num1)
    var num2: Int? = nil
    num2? = 10
    print(num2)` 
    
*   9.  给变量加上`?`是为了判断变量是否为`nil`，如果为`nil`，那么就不会执行赋值操作了，本质也是可选链
    
    swift
    
    复制代码
    
    `var dict: [String : (Int, Int) -> Int] = [
     "sum" : (+),
     "difference" : (-)
    ]
    var value = dict["sum"]?(10, 20)
    print(value)` 
    

从字典中通过key来取值，得到的也是可选类型，由于可选链中有一个节点是可选项，那么最后的结果也是可选项，最后的值也是`Int?`

三、协议（Protocol）
==============

1\. 基本概念
--------

*   1.  `协议`可以用来定义`方法`、`属性`、`下标`的声明  
        `协议`可以被`结构体`、`类`、`枚举`遵守
    
    swift
    
    复制代码
    
    `protocol Drawable {
     func draw()
     var x: Int { get set } // get和set只是声明
     var y: Int { get }
     subscript(index: Int) -> Int { get set }
    }` 
    
*   2.  `多个协议`之间用逗号隔开
    
    swift
    
    复制代码
    
    `protocol Test1 { }
    protocol Test2 { }
    protocol Test3 { }
    class TestClass: Test1, Test2, Test3 { }` 
    
*   3.  协议中定义方法时不能有默认参数值 ![-w633](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7119b8167f647fe819d6285c3c57f9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   4.  默认情况下，协议中定义的内容必须全部都实现

2\. 协议中的属性
----------

*   1.  `协议`中定义属性必须用`var`关键字
*   2.  实现`协议`时的属性权限要不小于`协议`中定义的`属性权限`
    
    *   协议定义`get、set`，用`var`存储属性或`get、set`计算属性去实现
    *   协议定义`get`，用任何属性都可以实现
    
    swift
    
    复制代码
    
    `protocol Drawable {
     func draw()
     var x: Int { get set }
     var y: Int { get }
     subscript(index: Int) -> Int { get set }
    }
    class Person1: Drawable {
     var x: Int = 0
     let y: Int = 0
     func draw() {
     print("Person1 draw")
     }
     subscript(index: Int) -> Int {
     set { }
     get { index }
     }
    }
    class Person2: Drawable {
     var x: Int {
     get { 0 }
     set { }
     }
     var y: Int { 0 }
     func draw() {
     print("Person2 draw")
     }
     subscript(index: Int) -> Int {
     set { }
     get { index }
     }
    }
    class Person3: Drawable {
     var x: Int {
     get { 0 }
     set { }
     }
     var y: Int {
     get { 0 }
     set { }
     }
     func draw() {
     print("Person3 draw")
     }
     subscript(index: Int) -> Int {
     set { }
     get { index }
     }
    }` 
    

3\. static、class
----------------

*   1.  为了保证通用，`协议`中必须用`static`定义`类型方法`、`类型属性`、`类型下标`
    
    swift
    
    复制代码
    
    `protocol Drawable {
     static func draw()
    }
    class Person1: Drawable {
     static func draw() {
     print("Person1 draw")
     }
    }
    class Person2: Drawable {
     class func draw() {
     print("Person2 draw")
     }
    }` 
    

4\. mutating
------------

*   1.  只有将`协议`中的`实例方法`标记为`mutating`，才允许`结构体`、`枚举`的具体实现修改自身内存
*   2.  `类`在实现方法时不用加`mutating`，`结构体`、`枚举`才需要加`mutating`
    
    swift
    
    复制代码
    
    `protocol Drawable {
     mutating func draw()
    }
    class Size: Drawable {
     var width: Int = 0
     func draw() {
     width = 10
     }
    }
    struct Point: Drawable {
     var x: Int = 0
     mutating func draw() {
     x = 10
     }
    }` 
    

5\. init
--------

*   1.  协议中还可以定义初始化器`init`，非`final`类实现时必须加上`required`
*   2.  目的是为了让所有遵守这个协议的类都拥有初始化器，所以加上`required`强制子类必须实现，除非是加上`final`不需要子类的类
    
    swift
    
    复制代码
    
    `protocol Drawable {
     init(x: Int, y: Int)
    }
    class Point: Drawable {
     required init(x: Int, y: Int) {
     }
    }
    final class Size: Drawable {
     init(x: Int, y: Int) {
     }
    }` 
    
*   3.  如果从协议实现的初始化器，刚好是重写了父类的指定初始化器，那么这个初始化必须同时加上`required、override`
    
    swift
    
    复制代码
    
    `protocol Livable {
     init(age: Int)
    }
    class Person {
     init(age: Int) { }
    }
    class Student: Person, Livable {
     required override init(age: Int) {
     super.init(age: age)
     }
    }` 
    
*   4.  协议中定义的`init?、init!`，可以用`init、init?、init!`去实现
    
    swift
    
    复制代码
    
    `protocol Livable {
     init()
     init?(age: Int)
     init!(no: Int)
    }
    class Person1: Livable {
     required init() {
     }
     required init?(age: Int) {
     }
     required init!(no: Int) {
     }
    }
    class Person2: Livable {
     required init() {
     }
     required init!(age: Int) {
     }
     required init?(no: Int) {
     }
    }
    class Person3: Livable {
     required init() {
     }
     required init(age: Int) {
     }
     required init(no: Int) {
     }
    }` 
    
*   5.  协议中定义的`init`，可以用`init、init!`去实现
    
    swift
    
    复制代码
    
    `protocol Livable {
     init()
     init?(age: Int)
     init!(no: Int)
    }
    class Person4: Livable {
     required init!() {
     }
     required init?(age: Int) {
     }
     required init!(no: Int) {
     }
    }` 
    

6\. 协议的继承
---------

一个`协议`可以继承其他协议

swift

复制代码

`protocol Runnable {
 func run()
}
protocol Livable: Runnable {
 func breath()
}
class Person: Livable {
 func breath() {
 }
 func run() {
 }
}` 

7\. 协议组合
--------

协议组合可以包含一个类类型

swift

复制代码

`protocol Runnable { }
protocol Livable { }
class Person { }
// 接收Person或者其子类的实例
func fn0(obj: Person) { }
// 接收遵守Livable协议的实例
func fn1(obj: Livable) { }
// 接收同时遵守Livable、Runnable协议的实例
func fn2(obj: Livable & Runnable) { }
// 接收同时遵守Livable、Runnable协议，并且是Person或者其子类的实例
func fn3(obj: Person & Livable & Runnable) { }
typealias RealPerson = Person & Livable & Runnable
func fn4(obj: RealPerson) { }` 

8\. CaseIterable
----------------

让枚举遵守`CaseIterable`协议，可以实现遍历枚举值

swift

复制代码

`enum Season: CaseIterable {
 case spring, summer, autumn, winter
}
let seasons = Season.allCases
print(seasons.count)
for season in seasons {
 print(season)
} // spring, summer, autumn, winter` 

9.CustomStringConvertible
-------------------------

*   1.  遵守`CustomStringConvertible、CustomDebugStringConvertible`协议，都可以自定义实例的打印字符串
    
    swift
    
    复制代码
    
    `class Person: CustomStringConvertible, CustomDebugStringConvertible {
     var age = 0
     var description: String { "person_(age)" }
     var debugDescription: String { "debug_person_(age)" }
    }
    var person = Person()
    print(person) // person_0
    debugPrint(person) // debug_person_0` 
    
*   2.  `print`调用的是`CustomStringConvertible`协议的`description`
*   3.  `debugPrint、po`调用的是`CustomDebugStringConvertible`协议的`debugDescription`

![-w529](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc8277e7aa14a60a23a27f52a4b11fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

四、Any、AnyObject与元类型
===================

1\. Any、AnyObject
-----------------

*   1.  Swift提供了两种特殊的类型`Any、AnyObject`
*   2.  `Any`可以代表任意类型（`枚举`、`结构体`、`类`，也包括`函数类型`）
    
    swift
    
    复制代码
    
    `var stu: Any = 10
    stu = "Jack"
    stu = Size()` 
    
    swift
    
    复制代码
    
    `var data = [Any]()
    data.append(1)
    data.append(3.14)
    data.append(Size())
    data.append("Jack")
    data.append({ 10 })` 
    
*   3.  `AnyObject`可以代表任意类类型
*   4.  在协议后面写上`: AnyObject`，代表只有类能遵守这个协议 ![-w644](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3809ed07d17450d911eec4ad2731c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   5.  在协议后面写上`: class`，也代表只有类能遵守这个协议 ![-w642](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c89cc874464f83a7bdb5c65a31b83c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

2\. is、as
---------

*   `is`用来判断是否为某种类型
    
    swift
    
    复制代码
    
    `protocol Runnable {
     func run()
    }
    class Person { }
    class Student: Person, Runnable {
     func run() {
     print("Student run")
     }
     func study() {
     print("Student study")
     }
    }
    var stu: Any = 10
    print(stu is Int) // true
    stu = "Jack"
    print(stu is String) // true
    stu = Student()
    print(stu is Person) // true
    print(stu is Student) // true
    print(stu is Runnable) // true` 
    
*   2.  `as`用来做强制类型转换(`as?`、`as!`、`as`)
    
    swift
    
    复制代码
    
    `protocol Runnable {
     func run()
    }
    class Person { }
    class Student: Person, Runnable {
     func run() {
     print("Student run")
     }
     func study() {
     print("Student study")
     }
    }
    var stu: Any = 10
    (stu as? Student)?.study() // 没有调用study
    stu = Student()
    (stu as? Student)?.study() // Student study
    (stu as! Student).study() // Student study
    (stu as? Runnable)?.run() // Student run` 
    
    swift
    
    复制代码
    
    `var data = [Any]()
    data.append(Int("123") as Any)
    var d = 10 as Double
    print(d) // 10.0` 
    

3\. X.self
----------

*   1.  `X.self`是一个`元类型的指针`，`metadata`存放着`类型相关信息`
*   2.  `X.self`属于`X.Type`类型
    
    swift
    
    复制代码
    
    `class Person { }
    class Student: Person { }
    var perType: Person.Type = Person.self
    var stuType: Student.Type = Student.self
    perType = Student.self
    var anyType: AnyObject.Type = Person.self
    anyType = Student.self
    var per = Person()
    perType = type(of: per)
    print(Person.self == type(of: per)) // true` 
    
*   3.  `AnyClass`的本质就是`AnyObject.Type` ![-w492](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c534ec2adb474b47bc5ab8ab7221b02a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
    
    swift
    
    复制代码
    
    `var anyType2: AnyClass = Person.self
    anyType2 = Student.self` 
    

4\. 元类型的应用
----------

swift

复制代码

`class Animal {
 required init() {
  
 }
}
class Cat: Animal {
  
}
class Dog: Animal {
  
}
class Pig: Animal {
  
}
func create(_ clses: [Animal.Type]) -> [Animal] {
 var arr = [Animal]()
 for cls in clses {
 arr.append(cls.init())
 }
  
 return arr
}
print(create([Cat.self, Dog.self, Pig.self]))
// a1、a2、a3、a4的写法等价
var a1 = Animal()
var t = Animal.self
var a2 = t.init()
var a3 = Animal.self.init()
var a4 = Animal.self()` 

5\. Self
--------

*   1.  `Self`代表当前类型
    
    swift
    
    复制代码
    
    `class Person {
     var age = 1
     static var count = 2
     func run() {
     print(self.age)
     print(Self.count)
     }
    }` 
    
*   2.  `Self`一般用作返回值类型，限定返回值和方法调用者必须是同一类型（也可以作为参数类型）
    
    swift
    
    复制代码
    
    `protocol Runnable {
     func test() -> Self
    }
    class Person: Runnable {
     required init() {
     }
     func test() -> Self {
     type(of: self).init()
     }
    }
    class Student: Person {
    }
    var p = Person()
    print(p.test()) // test_enum.Person
    var stu = Student()
    print(stu.test()) // test_enum.Student` 
    

6\. 元类型的本质
----------

我们可以通过反汇编来查看元类型的实现是怎样的

swift

复制代码

`var p = Person()
var pType = Person.self` 

我们发现最后存储到全局变量pType中的地址值就是一开始调用的地址 ![-w1031](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a38e68565b04a649793fd49e4962bc8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 再通过打印，我们发现pType的值就是Person实例对象的前8个字节的地址值，也就是类信息 ![-w1031](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81fff9375c949a18a6e71f733e06da5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![-w1032](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d84b816435c0422a9ea5bfde95b40861~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 我们再来看下面的示例代码

swift

复制代码

`var p = Person()
var pType = type(of: p)` 

通过分析我们可以看到`type(of: p)`本质不是函数调用，只是将Person实例对象的前8个字节存储到pType中，也证明了元类型的本质就是存储的类信息

![-w1031](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f11a754847b149eab14026ed50e0ff21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![-w1030](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa877aa499e7423e86c1e96bd301d291~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

我们还可以用以下方式来获取Swift的隐藏基类`_TtCs12_SwiftObject`

swift

复制代码

`class Person {
 var age: Int = 0
}
class Student: Person {
 var no: Int = 0
}
print(class_getInstanceSize(Student.self)) // 32
print(class_getSuperclass(Student.self)!) // Person
print(class_getSuperclass(Student.self)!) // _TtCs12_SwiftObject
print(class_getSuperclass(NSObject.self)) // nil` 

我们可以查看Swift源码来分析该类型

发现`SwiftObject`里面也有一个`isa指针`

![-w686](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4602a6c2194461caf1a20eefd72056b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

五、错误处理
======

1\. 错误处理
--------

### 1.1 错误类型

开发过程中常见的错误有

*   语法错误（编译报错）
*   逻辑错误
*   运行时错误（可能会导致闪退，一般也叫做异常）
*   ....

### 1.2 自定义错误

*   1.  Swift中可以通过`Error`协议自定义运行时的错误信息

swift

复制代码

`enum SomeError: Error {
 case illegalArg(String)
 case outOffBounds(Int, Int)
 case outOfMemory
}` 

*   2.  函数内部通过`throw`抛出自定义`Error`，可能会抛出`Error`的函数必须加上`throws`声明

swift

复制代码

`func divide(_ num1: Int, _ num2: Int) throws -> Int {
 if num2 == 0 {
 throw SomeError.illegalArg("0不能作为除数")
 }
 return num1 / num2
}` 

*   3.  需要使用`try`调用可能会抛出`Error`的函数

swift

复制代码

`var result = try divide(20, 10)` 

*   4.  抛出错误信息的情况 ![-w715](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7930b652084241faba9c27f010bc0d2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

### 1.3 do—catch

*   1.  可以使用`do—catch`捕捉`Error`

swift

复制代码

`do {
 try divide(20, 0)
} catch let error {
 switch error {
 case let SomeError.illegalArg(msg):
 print("参数错误", msg)
 default:
 print("其他错误")
 }
}` 

*   2.  抛出`Error`后，`try`下一句直到作用域结束的代码都将停止运行

swift

复制代码

`func test() {
 print("1")
 do {
 print("2")
 print(try divide(20, 0)) // 这句抛出异常后面的代码不会执行了
 print("3")
 } catch let SomeError.illegalArg(msg) {
 print("参数异常:", msg)
 } catch let SomeError.outOffBounds(size, index) {
 print("下标越界:", "size=(size)", "index=(index)")
 } catch SomeError.outOfMemory {
 print("内存溢出")
 } catch {
 print("其他错误")
 }
 print("4")
}
test()
//1
//2
//参数异常: 0不能作为除数
//4` 

*   3.  `catch`作用域内默认就有`error`的变量可以捕获

swift

复制代码

`do {
 try divide(20, 0)
} catch {
 print(error)
}` 

2\. 处理Error
-----------

*   1.  处理`Error`的两种方式:
*   a. 通过`do—catch`捕捉`Error`
    
    swift
    
    复制代码
    
    `do {
     print(try divide(20, 0))
    } catch is SomeError {
     print("SomeError")
    }` 
    
*   b. 不捕捉`Error`，在当前函数增加`throws`声明，`Error`将自动抛给上层函数  
    如果最顶层函数`main函数`依然没有捕捉`Error`，那么程序将终止
    
    swift
    
    复制代码
    
    `func test() throws {
     print("1")
     print(try divide(20, 0))
     print("2")
    }
    try test()
    // 1
    // Fatal error: Error raised at top level` 
    
*   2.  调用函数如果是写在函数里面，没有进行捕捉`Error`就会报错，而写在外面就不会 ![-w648](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b762799211d40e0a615dd5a6e22c6f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   3.  然后我们加上`do-catch`发现还是会报错，因为捕捉`Error`的处理不够详细，要捕捉所有`Error`信息才可以 ![-w639](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb1a1d7f29104af994f8efec21a18f1d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   这时我们加上`throws`就可以了
    
    swift
    
    复制代码
    
    `func test() throws {
     print("1")
     do {
     print("2")
     print(try divide(20, 0))
     print("3")
     } catch let error as SomeError {
     print(error)
     }
     print("4")
    }
    try test()
    // 1
    // 2
    // illegalArg("0不能作为除数")
    // 4` 
    
*   或者再加上一个`catch`捕获其他所有`Error`情况
    
    swift
    
    复制代码
    
    `func test() {
     print("1")
     do {
     print("2")
     print(try divide(20, 0))
     print("3")
     } catch let error as SomeError {
     print(error)
     } catch {
     print("其他错误情况")
     }
     print("4")
    }
    test()` 
    
*   看下面示例代码，执行后会输出什么
    
    swift
    
    复制代码
    
    `func test0() throws {
     print("1")
     try test1()
     print("2")
    }
    func test1() throws {
     print("3")
     try test2()
     print("4")
    }
    func test2() throws {
     print("5")
     try test3()
     print("6")
    }
    func test3() throws {
     print("7")
     try divide(20, 0)
     print("8")
    }
    try test0()` 
    
*   执行后打印如下，并会抛出错误信息 ![-w717](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0551c1a8ea45829511ba7bf79cfaa3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

3\. try
-------

*   1.  可以使用`try?、try!`调用可能会抛出`Error`的函数，这样就不用去处理`Error`

swift

复制代码

`func test() {
 print("1")
 var result1 = try? divide(20, 10) // Optional(2), Int?
 var result2 = try? divide(20, 0) // nil
 var result3 = try! divide(20, 10) // 2, Int
 print("2")
}
test()` 

*   2.  a、b是等价的

swift

复制代码

`var a = try? divide(20, 0)
var b: Int?
do {
 b = try divide(20, 0)
} catch { b = nil }` 

4\. rethrows
------------

*   `rethrows`表明，函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛

swift

复制代码

`func exec(_ fn: (Int, Int) throws -> Int, _ num1: Int, _ num2: Int) rethrows {
print(try fn(num1, num2))
}
// Fatal error: Error raised at top level
try exec(divide, 20, 0)` 

*   空合并运算符就是用了`rethrows`来进行声明的 ![-w609](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d973592ccd54e0a96c23cc6d9b4b4a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

5\. defer
---------

*   1.  `defer`语句，用来定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码
*   2.  `defer`语句将延迟至当前作用域结束之前执行

swift

复制代码

`func open(_ filename: String) -> Int {
print("open")
return 0
}
func close(_ file: Int) {
print("close")
}
func processFile(_ filename: String) throws {
let file = open(filename)
defer {
 close(file)
}
// 使用file
// .....
try divide(20, 0)
// close将会在这里调用
}
try processFile("test.txt")
// open
// close
// Fatal error: Error raised at top level` 

*   3.  `defer`语句的执行顺序与定义顺序相反

swift

复制代码

`func fn1() { print("fn1") }
func fn2() { print("fn2") }
func test() {
defer { fn1() }
defer { fn2() }
}
test()
// fn2
// fn1` 

6\. assert（断言）
--------------

*   很多编程语言都有断言机制，不符合指定条件就抛出运行时错误，常用于调试`Debug`阶段的条件判断 ![-w716](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd47e1150c04452aefc2cb0ff1fcefa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   默认情况下，Swift的断言只会在`Debug`模式下生效，`Release`模式下会忽略
*   增加`Swift Flags`修改断言的默认行为
*   `-assert-config Release`：强制关闭断言
*   `-assert-config Debug`：强制开启断言 ![-w716](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3876ff55e7b4d719e6639fb3f5f8e05~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

7\. fatalError
--------------

*   1.  如果遇到严重问题，希望结束程序运行时，可以直接使用`fatalError`函数抛出错误
*   2.  这是无法通过`do—catch`捕获的错误
*   3.  使用了`fatalError`函数，就不需要再写`return`

swift

复制代码

`func test(_ num: Int) -> Int {
 if num >= 0 {
 return 1
 }
 fatalError("num不能小于0")
}` 

*   4.  在某些不得不实现，但不希望别人调用的方法，可以考虑内部使用`fatalError`函数

swift

复制代码

`class Person { required init() {} }
class Student: Person {
 required init() {
 fatalError("don't call Student.init")
 }
 init(score: Int) {
 }
}
var stu1 = Student(score: 98)
var stu2 = Student()` 

8\. 局部作用域
---------

*   1.  可以使用`do`实现局部作用域

swift

复制代码

`do {
 let dog1 = Dog()
 dog1.age = 10
 dog1.run()
}
do {
 let dog2 = Dog()
 dog2.age = 10
 dog2.run()
}` 

六、泛型（Generics）
==============

1\. 基本概念
--------

*   1.1 `泛型`可以将`类型参数化`  
    提高代码复用率，减少代码量

swift

复制代码

`func swapValues<T>(_ a: inout T, _ b: inout T) {
 (a, b) = (b, a)
}
var i1 = 10
var i2 = 20
swap(&i1, &i2)
print(i1, i2) // 20, 10
struct Date {
 var year = 0, month = 0, day = 0
}
var d1 = Date(year: 2011, month: 9, day: 10)
var d2 = Date(year: 2012, month: 10, day: 20)
swap(&d1, &d2)
print(d1, d2) // Date(year: 2012, month: 10, day: 20), Date(year: 2011, month: 9, day: 10)` 

*   1.2 `泛型`函数赋值给变量

swift

复制代码

`func test<T1, T2>(_ t1: T1, _ t2: T2) {}
var fn: (Int, Double) -> () = test` 

2\. 泛型类型
--------

> Case1 `栈`

swift

复制代码

`class Stack<E> {
var elements = [E]()
func push(_ element: E) {
 elements.append(element)
}
func pop() -> E {
 elements.removeLast()
}
func top() -> E {
 elements.last!
}
func size() -> Int {
 elements.count
}
}
class SubStack<E>: Stack<E> {
}
var intStack = Stack<Int>()
var stringStack = Stack<String>()
var anyStack = Stack<Any>()` 

> Case1 `栈` 继续完善

swift

复制代码

`struct Stack<E> {
var elements = [E]()
mutating func push(_ element: E) {
 elements.append(element)
}
mutating func pop() -> E {
 elements.removeLast()
}
func top() -> E {
 elements.last!
}
func size() -> Int {
 elements.count
}
}
var stack = Stack<Int>()
stack.push(11)
stack.push(22)
stack.push(33)
print(stack.top()) // 33
print(stack.pop()) // 33
print(stack.pop()) // 22
print(stack.pop()) // 11
print(stack.size()) // 0` 

> Case2

swift

复制代码

`enum Score<T> {
case point(T)
case grade(String)
}
let score0 = Score<Int>.point(100)
let score1 = Score.point(99)
let score2 = Score.point(99.5)
let score3 = Score<Int>.grade("A")` 

3\. 关联类型（Associated Type）
-------------------------

*   1.  关联类型的作用: 给协议中用到的类型定义一个占位名称

swift

复制代码

`protocol Stackable {
 associatedtype Element
 mutating func push(_ element: Element)
 mutating func pop() -> Element
 func top() -> Element
 func size() -> Int
}
struct Stack<E>: Stackable {
 var elements = [E]()
 mutating func push(_ element: E) {
 elements.append(element)
 }
 mutating func pop() -> E {
 elements.removeLast()
 }
 func top() -> E {
 elements.last!
 }
 func size() -> Int {
 elements.count
 }
}
class StringStack: Stackable {
 var elements = [String]()
 func push(_ element: String) {
 elements.append(element)
 }
 func pop() -> String {
 elements.removeLast()
 }
 func top() -> String {
 elements.last!
 }
 func size() -> Int {
 elements.count
 }
}
var ss = StringStack()
ss.push("Jack")
ss.push("Rose")` 

*   2.  协议中可以拥有多个关联类型

swift

复制代码

`protocol Stackable {
 associatedtype Element
 associatedtype Element2
 mutating func push(_ element: Element)
 mutating func pop() -> Element
 func top() -> Element
 func size() -> Int
}` 

4\. 类型约束
--------

swift

复制代码

`protocol Runnable { }
class Person { }
func swapValues<T: Person & Runnable>(_ a: inout T, _ b: inout T) {
(a, b) = (b, a)
}` 

swift

复制代码

`protocol Stackable {
associatedtype Element: Equatable
}
class Stack<E: Equatable>: Stackable {
typealias Element = E
}
func equal<S1: Stackable, S2: Stackable>(_ s1: S1, _ s2: S2) -> Bool where S1.Element == S2.Element, S1.Element : Hashable {
 return false
}
var stack1 = Stack<Int>()
var stack2 = Stack<String>()
equal(stack1, stack2)` 

5\. 协议类型的注意点
------------

看下面的示例代码来分析

swift

复制代码

`protocol Runnable { }
class Person: Runnable { }
class Car: Runnable { }
func get(_ type: Int) -> Runnable {
if type == 0 {
 return Person()
}
return Car()
}
var r1 = get(0)
var r2 = get(1)` 

*   如果协议中有`associatedtype`

swift

复制代码

`protocol Runnable {
associatedtype Speed
var speed: Speed { get }
}
class Person: Runnable {
var speed: Double { 0.0 }
}
class Car: Runnable {
var speed: Int { 0 }
}` 

*   这样写会报错，因为无法在编译阶段知道`Speed`的真实类型是什么 ![-w638](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efce02a4842a49258ed91629e11c620f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   可以用泛型来解决

swift

复制代码

`protocol Runnable {
 associatedtype Speed
 var speed: Speed { get }
}
class Person: Runnable {
 var speed: Double { 0.0 }
}
class Car: Runnable {
 var speed: Int { 0 }
}
func get<T: Runnable>(_ type: Int) -> T {
 if type == 0 {
 return Person() as! T
 }
 return Car() as! T
}
var r1: Person = get(0)
var r2: Car = get(1)` 

*   还可以使用`some`关键字声明一个`不透明类型`
*   `some`限制只能返回一种类型

swift

复制代码

`protocol Runnable {
 associatedtype Speed
 var speed: Speed { get }
}
class Person: Runnable {
 var speed: Double { 0.0 }
}
class Car: Runnable {
 var speed: Int { 0 }
}
func get(_ type: Int) -> some Runnable {
 return Car()
}
var r1 = get(0)
var r2 = get(1)` 

*   `some`除了用在返回值类型上，一般还可以用在属性类型上

swift

复制代码

`protocol Runnable {
 associatedtype Speed
}
class Dog: Runnable {
 typealias Speed = Double
}
class Person {
 var pet: some Runnable {
 return Dog()
 }
}` 

6\. 泛型的本质
---------

*   我们通过下面的示例代码来分析其内部具体是怎样实现的

swift

复制代码

`func swapValues<T>(_ a: inout T, _ b: inout T) {
 (a, b) = (b, a)
}
var i1 = 10
var i2 = 20
swap(&i1, &i2)
print(i1, i2) // 20, 10
var d1 = 10.0
var d2 = 20.0
swap(&d1, &d2)
print(d1, d2) // 20.0, 10.0` 

*   反汇编之后 ![-w1000](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/281c636f9b5b4cbba84bea1f8833610d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![-w1002](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/423e799fe8324208b6a7ec356a5c90ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   从调用两个交换方法来看，最终调用的都是同一个函数，因为函数地址是一样的；
*   但不同的是分别会将`Int的metadata`和`Double的metadata`作为参数传递进去
*   所以推测`metadata`中应该分别指明对应的类型来做处理

7\. 可选项的本质
----------

*   1.  可选项的本质的本质是`enum`类型
*   2.  我们可以进到头文件中查看 ![-w1034](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e338908efc74aa6b8f35758510ebafa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
*   我们平时写的语法糖的真正写法如下:

swift

复制代码

`var age: Int? = 10
本质写法如下：
var ageOpt0: Optional<Int> = Optional<Int>.some(10)
var ageOpt1: Optional = .some(10)
var ageOpt2 = Optional.some(10)
var ageOpt3 = Optional(10)` 

swift

复制代码

`var age: Int? = nil
本质写法如下：
var ageOpt0: Optional<Int> = .none
var ageOpt1 = Optional<Int>.none` 

swift

复制代码

`var age: Int? = .none
age = 10
age = .some(20)
age = nil` 

*   3.  switch中可选项的使用

swift

复制代码

`switch age {
case let v?: // 加上?表示如果有值会解包赋值给v
 print("some", v)
case nil:
 print("none")
}
switch age {
case let .some(v):
 print("some", v)
case .none:
 print("none")
}` 

*   4.  多重可选项

swift

复制代码

`var age_: Int? = 10
var age: Int?? = age_
age = nil
var age0 = Optional.some(Optional.some(10))
age0 = .none
var age1: Optional<Optional> = .some(.some(10))
age1 = .none` 

swift

复制代码

`var age: Int?? = 10
var age0: Optional<Optional> = 10` 
