
 [什么情况使用 weak 关键字，相比 assign 有什么不同？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#什么情况使用-weak-关键字相比-assign-有什么不同) 
 
 [怎么用 copy 关键字？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#怎么用-copy-关键字) 
 
 [这个写法会出什么问题： @property (copy) NSMutableArray *array;](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#这个写法会出什么问题-property-copy-nsmutablearray-array) 
 
 [如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter) 
 
 [@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的) 
 
 [@protocol 和 category 中如何使用 @property](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#protocol-和-category-中如何使用-property) 
 
 [runtime 如何实现 weak 属性](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#runtime-如何实现-weak-属性) 
 
 [@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#property中有哪些属性关键字-property-后面可以有哪些修饰符) 
 
 [weak属性需要在dealloc中置nil么？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#weak属性需要在dealloc中置nil么)
 
 [@synthesize和@dynamic分别有什么作用？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#synthesize和dynamic分别有什么作用) 
 
 [ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#arc下不显式指定任何属性关键字时默认的关键字都有哪些) 
 
 [用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题) 
 
  [对非集合类对象的copy操作](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#1-对非集合类对象的copy操作)
   
  [集合类对象的copy与mutableCopy](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#2集合类对象的copy与mutablecopy) 
  
 [@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么) 
 
 [在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景) 
 
[objc使用什么机制管理对象内存？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#objc使用什么机制管理对象内存) 

 [ARC通过什么方式帮助开发者管理内存？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#arc通过什么方式帮助开发者管理内存) 
 
 [不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建) 
 
 [BAD_ACCESS在什么情况下出现？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#bad_access在什么情况下出现) 
 
 [苹果是如何实现autoreleasepool的？](https://github.com/shenchunxing/ios_interview_questions/blob/master/内存管理.md#苹果是如何实现autoreleasepool的) 
 
 

### 什么情况使用 weak 关键字，相比 assign 有什么不同？
什么情况使用 weak 关键字？


 1. 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性

 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***

不同点：
 
 1. `weak` 修饰符表明该属性定义了一种“非拥有关系” (nonowning relationship)。在为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此行为与 assign 类似，不同之处在于，在 weak 属性所指的对象遭到销毁、释放时，该属性值也会清空(nil out)。而 `assign` 的“设置方法”只会执行针对“纯量类型/基本数据类型” (scalar type，例如 CGFloat 或 
NSInteger 等)的简单赋值操作。

 2. assign 可以用非 OC 对象,而 weak 必须用于 OC 对象

其他讨论见： [《第2题 #89》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/89 ) 

### 怎么用 copy 关键字？
用途：

 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
 2. block 也经常使用 copy 关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：

  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.
  
  在 ARC 中写不写都行：
  
  在 ARC 环境下，编译器会根据情況自动将栈上的 block 复制到堆上，比如以下情况：

- block 作为函数返回值时
- 将 block 赋值给 __strong 指针时（property 的 copy 属性对应的是这一条）
- block 作为 Cocoa API 中方法名含有 using Block 的方法参数时
- block 作为 GCD API 的方法参数时

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfj47m0v1wj30s01cak0r.jpg)
  
其中， block 的 property 设置为 copy， 对应的是这一条：将 block 赋值给 __strong 指针时。

  
  
  换句话说：
  
  对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写还依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？

 ```Objective-C
 @property (nonatomic, copy) NSString *userId;

 - (instancetype)initWithUserId:(NSString *)userId {
    self = [super init];
    if (!self) {
        return nil;
    }
    _userId = [userId copy];
    return self;
 }

 ```

 ![https://github.com/ChenYilong](http://i.imgur.com/VlVKl8L.png)

下面做下解释：
 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。


> 用 `@property` 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。
 
该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***


### 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`
两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； 

第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。

比如下面的代码就会发生崩溃

 
 
```Objective-C
// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

@property (nonatomic, copy) NSMutableArray *mutableArray;
```


```Objective-C
// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];
```

接下来就会奔溃：

 
```Objective-C
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
```



第2条原因，如下：

> 该属性使用了互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。），会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。

在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。）。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。

在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。

一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的加锁机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。

因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用
 atomic 属性通常都不会有性能瓶颈。

如果对题有疑问，可参考讨论区： [《第四题 #62》](https://github.com/ChenYilong/iOSInterviewQuestions/issues/62) 

### 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？


> 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 `NSCopying` 与 `NSMutableCopying` 协议。




具体步骤：

 1. 需声明该类遵从 NSCopying 协议
 2. 实现 NSCopying 协议。该协议只有一个方法: 

 ```Objective-C
- (id)copyWithZone:(NSZone *)zone;
```
注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。

以第一题的代码为例：
   

 ```Objective-C
	// .h文件
	// http://weibo.com/luohanchenyilong/
	// https://github.com/ChenYilong
	// 修改完的代码

	typedef NS_ENUM(NSInteger, CYLGender) {
	    CYLGenderUndefined,
	    CYLGenderMale,
	    CYLGenderFemale
	};

	@interface CYLUser : NSObject<NSCopying>

	@property (nonatomic, readonly, copy) NSString *name;
	@property (nonatomic, readonly, assign) NSUInteger age;
	@property (nonatomic, readonly, assign) CYLGender gender;

	- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;
	+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;

	@end
 ```


然后实现协议中规定的方法：

 
```Objective-C
- (id)copyWithZone:(NSZone *)zone {
	CYLUser *copy = [[[self class] allocWithZone:zone] 
		             initWithName:_name
 							      age:_age
						          gender:_gender];
	return copy;
}
```

但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:

```Objective-C
// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLGender) {
    CYLGenderUndefined,
    CYLGenderMale,
    CYLGenderFemale
};

@interface CYLUser : NSObject<NSCopying>

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLGender gender;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
```

// .m文件



 ```Objective-C
// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
//

@implementation CYLUser {
    NSMutableSet *_friends;
}

- (instancetype)initWithName:(NSString *)name
                         age:(NSUInteger)age
                         gender:(CYLGender)gender {
    if (self = [super init]) {
        _name = [name copy];
        _age = age;
        _gender = gender;
        _friends = [[NSMutableSet alloc] init];
    }
    return self;
}

+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender {
    CYLUser *user = [[CYLUser alloc] initWithName:name age:age gender:gender];
    user->_friends = [[NSMutableSet alloc] init];
    return user;
}

- (void)addFriend:(CYLUser *)user {
    [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
    [_friends removeObject:user];
}

- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self class] allocWithZone:zone]
                     initWithName:_name
                     age:_age
                     gender:_gender];
    copy->_friends = [_friends mutableCopy];
    return copy;
}

@end

 ```

以上做法能满足基本的需求，但是也有缺陷：

> 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。

【注：深浅拷贝的概念，在下文中有介绍，详见下文的：***用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？***】

在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:
	

 ```Objective-C
- (id)deepCopy {
    CYLUser *copy = [[[self class] alloc]
                     initWithName:_name
                     age:_age
                     gender:_gender];
    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                             copyItems:YES];
    return copy;
}

 ```

注意：由于上文中 `CYLUser` 的 `-copyWithZone` 方法里，`_friends` 成员的的赋值使用的 `- mutableCopy` 是浅拷贝，只是创建了`NSMutableSet` 对象； 导致 `- deepCopy` 方法中， `_friends` 的每一个对象的 `_friends` 列表并未创建实例。如需继续优化，还需要改造。参见这里的讨论：https://github.com/ChenYilong/iOSInterviewQuestions/pull/24  欢迎大家可以在链接 issue 中贡献自己的想法进行讨论

至于***如何重写带 copy 关键字的 setter***这个问题，


如果抛开本例来回答的话，如下：


 
```Objective-C
- (void)setName:(NSString *)name {
    //[_name release];
    _name = [name copy];
}
```

不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”


 ```Objective-C
- (void)setName:(NSString *)name {
    if (_name != name) {
        //[_name release];//MRC
        _name = [name copy];
    }
}
 ```



这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在 ARC 时代的实际开发中，它更像下图里的做法：

![https://github.com/ChenYilong](http://i.imgur.com/UwV9oSn.jpeg)

克强总理这样评价你的代码风格：

![https://github.com/ChenYilong](http://i.imgur.com/N77Lkic.png)

我和总理的意见基本一致：


> 老百姓 copy 一下，咋就这么难？


你可能会说：

 
之所以在这里做`if判断` 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。
(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)


但是你有没有考虑过代价：


> 你每次调用 `setX:` 都会做 if 判断，这会让 `setX:` 变慢，如果你在 `setX:`写了一串复杂的 `if+elseif+elseif+...` 判断，将会更慢。

要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：

```Objective-C
[a setX:x1];
[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？
```

或者


```Objective-C
[a setX:[a x]];   //队友咆哮道：你在干嘛？！！
```

> ARC时代下，不要在 setter 里进行像 `if (_obj != newObj)` 这样的判断。（该观点参考链接：[ ***How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure*** ](http://vgable.com/blog/tag/autorelease/)
）


ARC时代下，什么情况会在 copy setter 里做 if 判断？

例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：

 
```Objective-C
-(void)setSpeed:(int)speed {
    if (speed < 0) speed = 0;
    if (speed > 300) speed = 300;
   _speed = speed;
}
```



回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”--copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。

那如何确保 name 被 copy？在初始化方法(initializer)中做：

 ```Objective-C
	- (instancetype)initWithName:(NSString *)name 
								 age:(NSUInteger)age 
								 gender:(CYLGender)gender {
	     if ((self = [super init]) {
	     	_name = [name copy];
	     	_age = age;
	     	_gender = gender;
	     	_friends = [[NSMutableSet alloc] init];
	     }
	     return self;
	}

 ```


讨论区：

-  [《set中，对if (_name != name)的描述 #10》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/10 ) 
- [《更新问题 “如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？” 的答案 #24》]( https://github.com/ChenYilong/iOSInterviewQuestions/pull/24 ) 

### @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的

**@property 的本质是什么？**

> @property = ivar + getter + setter;

下面解释下：

> “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 `Objective-C 2.0` 的一部分。
而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:

> 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：

> @property = getter + setter;

例如下面这个类：



 ```Objective-C
@interface Person : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
 ```


上述代码写出来的类与下面这种写法等效：



 ```Objective-C
@interface Person : NSObject
- (NSString *)firstName;
- (void)setFirstName:(NSString *)firstName;
- (NSString *)lastName;
- (void)setLastName:(NSString *)lastName;
@end
 ```
 
对上面这一句有疑问，可参考讨论区： [《第6题 上述代码写出来的类与下面这种写法等效： #86》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/86 ) 

**更新**：

property在runtime中是`objc_property_t`定义如下:

```objective-c
typedef struct objc_property *objc_property_t;
```

而`objc_property`是一个结构体，包括name和attributes，定义如下：

```objective-c
struct property_t {
    const char *name;
    const char *attributes;
};
```

而attributes本质是`objc_property_attribute_t`，定义了property的一些属性，定义如下：

```objective-c
/// Defines a property attribute
typedef struct {
    const char *name;           /**< The name of the attribute */
    const char *value;          /**< The value of the attribute (usually empty) */
} objc_property_attribute_t;
```

而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。

例如：我们定义一个string的property`@property (nonatomic, copy) NSString *string;`，通过 `property_getAttributes(property)`获取到attributes并打印出来之后的结果为`T@"NSString",C,N,V_string`

其中T就代表类型，可参阅[Type Encodings](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)，C就代表Copy，N代表nonatomic，V就代表对应的实例变量。



**ivar、getter、setter 是如何生成并添加到这个类中的?**

> “自动合成”( autosynthesis)

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
 `_firstName` 与 `_lastName`。也可以在类的实现代码里通过
 `@synthesize` 语法来指定实例变量的名字.



 ```Objective-C
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
 ```

我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西

 1. `OBJC_IVAR_$类名$属性名称` ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
 2. setter 与 getter 方法对应的实现函数
 3. `ivar_list` ：成员变量列表
 4. `method_list` ：方法列表
 5. `prop_list` ：属性列表


也就是说我们每次在增加一个属性,系统都会在 `ivar_list` 中添加一个成员变量的描述,在 `method_list` 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转。

注意：其中 prop_list 存在哪里？

 ```c
//objc-runtime-new.h中
struct objc_class : objc_object {
//...
class_data_bits_t bits;//在bits.data()里面
//...
}
 ```
 

注意在iOS 10, Xcode 8推出的class关键字中, 与本题中关于 `@property` 的讨论, 有一些差异, 比如
 
class关键字表示永远不会自动合成，所以类变量、类存取方法，都要自己手动实现；

下文中的第9题会涉及这个关键字的用法，可以参考下文。

 讨论见： [《第六题 prop_list 存在哪里？ #108》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/108 ) 

 
 


### @protocol 和 category 中如何使用 @property

 1. 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
 2. category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：

  1. `objc_setAssociatedObject`
  2. `objc_getAssociatedObject`

对该回答有疑问，可参考讨论区 [《第7题，在代理里定义属性，好像没有使用场景吧 #83》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/83 ) 

### runtime 如何实现 weak 属性

要实现 weak 属性，首先要搞清楚 weak 属性的特点：

> weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。

那么 runtime 如何实现 weak 变量的自动置nil？

举例说明：

 ```Objective-C
    id obj0 = [NSObject new];
    __weak id obj1 = obj0;
    __weak id objA = obj0;

 ```

> runtime 对注册的类，会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指针(obj1、objA)指向的对象(obj0)内存地址作为 key，当此对象的引用计数为0的时候会反向找到 weak 指针(obj1、objA) 并 dealloc。假如 weak 指针(obj1、objA)指向的对象(obj0)内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象(obj1、objA)，从而设置为 nil。

（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到`__weak`引用的解除时间。）


先看下 runtime 里源码的实现：


 ```Objective-C
/**
 * The internal structure stored in the weak references table. 
 * It maintains and stores
 * a hash set of weak references pointing to an object.
 * If out_of_line==0, the set is instead a small inline array.
 */
#define WEAK_INLINE_COUNT 4
struct weak_entry_t {
    DisguisedPtr<objc_object> referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line : 1;
            uintptr_t        num_refs : PTR_MINUS_1;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line=0 is LSB of one of these (don't care which)
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
};

/**
 * The global weak references table. Stores object ids as keys,
 * and weak_entry_t structs as their values.
 */
struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};
 ```

具体完整实现参照 [objc/objc-weak.h](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h) 。



我们可以设计一个函数（伪代码）来表示上述机制：

`objc_storeWeak(&a, b)`函数：

`objc_storeWeak`函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，

你可以把`objc_storeWeak(&a, b)`理解为：`objc_storeWeak(value, key)`，并且当key变nil，将value置nil。(如对这句话有疑问，可以参考讨论 [《第8题 感觉objc_storeWeak(&a, b) 理解有点问题 #98》](https://github.com/ChenYilong/iOSInterviewQuestions/issues/98) )


在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。

而如果a是由 assign 修饰的，则：
在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息会产生崩溃。


下面我们将基于`objc_storeWeak(&a, b)`函数，使用伪代码模拟“runtime如何实现weak属性”：
 


 
```Objective-C
// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

 id obj1;
 objc_initWeak(&obj1, obj);
/*obj引用计数变为0，变量作用域结束*/
 objc_destroyWeak(&obj1);
```

下面对用到的两个方法`objc_initWeak`和`objc_destroyWeak`做下解释：

总体说来，作用是：
通过`objc_initWeak`函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过`objc_destoryWeak`函数释放该变量（obj1）。

下面分别介绍下方法的内部实现：

`objc_initWeak`函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用`objc_storeWeak`函数。



 
```Objective-C
obj1 = 0；
obj_storeWeak(&obj1, obj);
```

也就是说：

>  weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）

(同时， weak 修饰的指针可能随时变为 nil)

然后`obj_destroyWeak`函数将0（nil）作为参数，调用`objc_storeWeak`函数。

`objc_storeWeak(&obj1, 0);`

前面的源代码与下列源代码相同。


```Objective-C
// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

id obj1;
obj1 = 0;
objc_storeWeak(&obj1, obj);
/* ... obj的引用计数变为0，被置nil ... */
objc_storeWeak(&obj1, 0);
```


`objc_storeWeak` 函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。

使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：

> 如何让不使用weak修饰的@property，拥有weak的效果。


我们从setter方法入手：

（注意以下的 `cyl_runAtDealloc` 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) ）

 ```Objective-C
- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
 ```

也就是有两个步骤：

 1. 在setter方法中做如下设置：


 ```Objective-C
        objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
 ```

 2. 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：
 
 ```Objective-C
//要销毁的目标对象
id objectToBeDeallocated;
//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。
id objectWeWantToBeReleasedWhenThatHappens;
objc_setAssociatedObject(objectToBeDeallocted,
                         someUniqueKey,
                         objectWeWantToBeReleasedWhenThatHappens,
                         OBJC_ASSOCIATION_RETAIN);
```

知道了思路，我们就开始实现 `cyl_runAtDealloc` 方法，实现过程分两部分：

第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。

// .h文件

 ```Objective-C
// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

typedef void (^voidBlock)(void);

@interface CYLBlockExecutor : NSObject

- (id)initWithBlock:(voidBlock)block;

@end
 ```

// .m文件

 ```Objective-C
// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

#import "CYLBlockExecutor.h"

@interface CYLBlockExecutor() {
    voidBlock _block;
}
@implementation CYLBlockExecutor

- (id)initWithBlock:(voidBlock)aBlock
{
    self = [super init];
    
    if (self) {
        _block = [aBlock copy];
    }
    
    return self;
}

- (void)dealloc
{
    _block ? _block() : nil;
}

@end
 ```

第二部分：核心代码：利用runtime实现`cyl_runAtDealloc`方法

 ```Objective-C
// CYLNSObject+RunAtDealloc.h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLBlockExecutor.h"

const void *runAtDeallocBlockKey = &runAtDeallocBlockKey;

@interface NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block;

@end


// CYLNSObject+RunAtDealloc.m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLNSObject+RunAtDealloc.h"
#import "CYLBlockExecutor.h"

@implementation NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block
{
    if (block) {
        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];
        
        objc_setAssociatedObject(self,
                                 runAtDeallocBlockKey,
                                 executor,
                                 OBJC_ASSOCIATION_RETAIN);
    }
}

@end
 ```

使用方法：
导入


 ```Objective-C
    #import "CYLNSObject+RunAtDealloc.h"
 ```

然后就可以使用了：


 ```Objective-C
NSObject *foo = [[NSObject alloc] init];

[foo cyl_runAtDealloc:^{
    NSLog(@"正在释放foo!");
}];
 ```


如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) 

参考博文： [***Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object***](http://stackoverflow.com/a/31560217/3395008)

更多疑问, 可以参与issue讨论: 

- [《第8题 感觉objc_storeWeak(&a, b)哪里理解有点问题 #98》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/98 ) 
- [《第8题 有一点说的很容易误导人 #6》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/6 ) 

### @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？
属性可以拥有的特质分为四类:
 
 1. 原子性--- `nonatomic` 特质

    在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。）。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。

 1. 读/写权限---`readwrite(读写)`、`readonly (只读)`
 2. 内存管理语义---`assign`、`strong`、 `weak`、`unsafe_unretained`、`copy`、`class`
 3. 方法名---`getter=<name>` 、`setter=<name>`
   
  `getter=<name>`的样式：


 ```Objective-C
        @property (nonatomic, getter=isOn) BOOL on;
 ```
 <p><del>（ `setter=<name>`这种不常用，也不推荐使用。故不在这里给出写法。）
</del></p>


 `setter=<name>`一般用在特殊的情境下，比如：


在数据反序列化、转模型的过程中，服务器返回的字段如果以 `init` 开头，所以你需要定义一个 `init` 开头的属性，但默认生成的 `setter` 与 `getter` 方法也会以 `init` 开头，而编译器会把所有以 `init` 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。

这时你就可以使用下面的方式来避免编译器报错：


 ```Objective-C
@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;

 ```


另外也可以用关键字进行特殊说明，来避免编译器报错：

 ```Objective-C
@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;
- (NSString *)initBy __attribute__((objc_method_family(none)));
 ```

 1. 其他：`nonnull`,`null_resettable`,`nullable`


注意：很多人会认为如果属性具备 nonatomic 特质，则不使用
“同步锁”。其实在属性设置方法中使用的是互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。），相关代码如下：


 ```Objective-C
static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t& slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }

    objc_release(oldValue);
}

void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) 
{
    bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);
    bool mutableCopy = (shouldCopy == MUTABLE_COPY);
    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);
}
 ```

补充说明:

其中内存管理语义中的class关键字， 是在 iOS 10, Xcode 8 后推出的， 可以与 Swift 里的 static 和 class 关键字进行桥接， 

class 关键字表示永远不会自动合成，所以类变量、类存取方法，都要自己手动实现；常常与 `@dynamic` 搭配使用。

主要用法可以参考如下：

好处就是单例的 get 方法(sharedInstance方法)可以有智能提示：

 ```Objective-C
@interface Foo : NSObject
@property (nonatomic, class, readonly) Foo *sharedFoo;
@end

@implementation Foo
/**
 * 作用与下面的写法一致: 
 * + (instancetype)sharedInstance 
 */
+ (Foo *)sharedInstance {
    static Foo *_sharedFoo = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _sharedFoo = [[self alloc] init];
    });
    return _sharedFoo;
}

 ```
 
### weak属性需要在dealloc中置nil么？

不需要。


> 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理

即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：

正如上文的：***runtime 如何实现 weak 属性*** 中提到的：

我们模拟下 weak 的 setter 方法，应该如下：


 ```Objective-C
- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
 ```

如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) 


也即:

> 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。



### @synthesize和@dynamic分别有什么作用？

 1. @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是`@syntheszie var = _var;`
 2. @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
 3. @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 `instance.var = someVar`，由于缺 setter 方法会导致程序崩溃；或者当运行到 `someVar = var` 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

讨论区： [《上篇第11题，@dynamic那里说明有点问题 #26》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/26 ) 

### ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？

1 对应基本数据类型默认关键字是
 
  - `atomic`
  - `readwrite`
  - `assign`
 
2 对于普通的 Objective-C 对象
  
  - `atomic`
  - `readwrite`
  - `strong`


Objective-C 对象默认是 strong，因为你 `class_copyPropertyList` 后再`property_getAttributes` 得到的是`T@"NSString",&,V_name`，其中`&`表示strong（c表示copy等）；

普通对象是 `assign`，这个获取不到文档说明，但是我们可以从 runtime 源码中找到相关的逻辑，你看看 `objc_AssociationPolicy` 枚举的定义以及内部处理的逻辑就知道了，还有一点就是属性加不加 assign 用 `property_getAttributes` 得到的都是一样的值，可以返推回去结论成立。

参考链接：

 1. [ ***Objective-C ARC: strong vs retain and weak vs assign*** ](http://stackoverflow.com/a/15541801/3395008)

 2. [ ***Variable property attributes or Modifiers in iOS*** ](http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html)

### 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？


 1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
 2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.

 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。


举例说明：

定义一个以 strong 修饰的 array：

 ```Objective-C
@property (nonatomic, readwrite, strong) NSArray *array;
 ```

然后进行下面的操作：

 ```Objective-C
    NSArray *array = @[ @1, @2, @3, @4 ];
    NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
    
    self.array = mutableArray;
    [mutableArray removeAllObjects];;
    NSLog(@"%@",self.array);
    
    [mutableArray addObjectsFromArray:array];
    self.array = [mutableArray copy];
    [mutableArray removeAllObjects];;
    NSLog(@"%@",self.array);
 ```

打印结果如下所示：

 ```Objective-C
2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (
)
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (
    1,
    2,
    3,
    4
)
 ```

（详见仓库内附录的 Demo。）


为了理解这种做法，首先要知道，两种情况：


 1. 对非集合类对象的 copy 与 mutableCopy 操作；
 2. 对集合类对象的 copy 与 mutableCopy 操作。

讨论区： 

- [《13题好像只有NSString符合你说的前两点特性 #29》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/29 ) 
-  [《第13题 疑问 对非集合类对象的copy操作 #19》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/19 ) 

#### 1. 对非集合类对象的copy操作：

先说结论:

在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：

 ```Objective-C
 [immutableObject copy] // 浅复制
 [immutableObject mutableCopy] //深复制
 [mutableObject copy] //深复制
 [mutableObject mutableCopy] //深复制
 ```
	
根据上面的结论，我们也可以总结出规律：

对于非集合类对象而言，从不可变转换到另一个不可变，因为没必要创建一个新对象出来， 所以是浅拷贝。
而不可变与可变对象的互相转换过程中、从一个可变到另一个可变， 为了不影响可变对象的可变特性，必须要创建一个新对象出来，所以是深拷贝。

下面详细讲下: 

比如以下代码：


 ```Objective-C
NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy];
 ```


查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：


 ```Objective-C
[string appendString:@"origion!"]
 ```

stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。
  集合类对象以此类推。
所以，

> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

#### 2、集合类对象的copy与mutableCopy

先说结论:

从集合内的元素的角度而言, 对任何集合对象(可变和不可变集合)进行的 copy 与 mutableCopy 操作都可以称之为浅拷贝。

 ```Objective-C
[immutableCollectionObject copy] // 浅拷贝
[immutableCollectionObject mutableCopy] //浅拷贝
[mutableCollectionObject copy] //浅拷贝
[mutableCollectionObject mutableCopy] //浅拷贝
 ```
 
因为无论是进行copy还是进行mutableCopy, 集合内部的元素仍然是指针拷贝。

考虑到集合对象我们更关注内部元素，而非集合本身，我更倾向于认为这个就是浅拷贝。

当然如果从集合本身的角度，这里就会有一些争议，我们可以详细讲下：

集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：

 ```Objective-C
NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
 ```

查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：


 ```Objective-C
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
 ```


查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：

在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：


 ```Objective-C
[immutableCollectionObject copy] // 浅拷贝
[immutableCollectionObject mutableCopy] //浅拷贝，也可以称之为“单层深拷贝”。
[mutableCollectionObject copy] //浅拷贝，也可以称之为“单层深拷贝”。
[mutableCollectionObject mutableCopy] //浅拷贝，也可以称之为“单层深拷贝”。
 ```

这个代码结论和非集合类的结论有区别，注意分辨。

注意：“深拷贝”前面为什么要加一个“单层”? 原因如下：对于集合对象的 copy 操作是否属于深拷贝这里有争议，因为 copy 操作后，集合对象内部的元素实际并没有变更指针地址，所以严格意义上来说，集合对象的 copy 操作也可以称之为浅拷贝。上文中，所谓的深拷贝，没有考虑集合内部元素层面，仅仅考虑了该集合对象的指针。所以仅仅是“单层深复制”，也可以称之为浅拷贝。但考虑到集合对象我们更关注元素，而非集合本身，我们更倾向于认为这个就是浅拷贝。

参考链接：[iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)

### @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为`_foo`的实例变量，那么还会自动合成新变量么？
在回答之前先说明下一个概念：

> 实例变量 = 成员变量 ＝ ivar

这些说法，笔者下文中，可能都会用到，指的是一个东西。


正如
[Apple官方文档 ***You Can Customize Synthesized Instance Variable Names***](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6) 所说：
![https://github.com/ChenYilong](http://i.imgur.com/D6d0zGJ.png)

如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。

 
```Objective-C
@interface CYLPerson : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end
```


在上例中，会生成两个实例变量，其名称分别为
 `_firstName` 与 `_lastName`。也可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:
 
```Objective-C
@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
```



上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName` ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以“下划线”来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。

总结下 @synthesize 合成实例变量的规则，有以下几点：


 1 如果指定了成员变量的名称,会生成一个指定的名称的成员变量,

 2 如果这个成员已经存在了就不再生成了.
 3 如果是 `@synthesize foo;` 还会生成一个名称为foo的成员变量，也就是说：

 > 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,



 4 如果是 `@synthesize foo = _foo;` 就不会生成成员变量了.

假如 property 名为 foo，存在一个名为 `_foo` 的实例变量，那么还会自动合成新变量么？

 <p><del>不会。如下图：</del></p>

与编译环境有关, 低版本不会, 高版本会

低版本:

![https://github.com/ChenYilong](http://i.imgur.com/t28ge4W.png)


而在 Xcode 12.5，如果存在一个名为 `_object` 实例变量，有个property名为`_object`，会合成新变量 `__object`

同时如果没有显示定义 `_objcect` 实例变量，定义属性 `_object` 也会生成 `__object` 实例变量

![](https://i.loli.net/2021/08/31/okeqdpgbRt1u74V.png)



### 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？

回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？

 1. 同时重写了 setter 和 getter 时
 2. 重写了只读属性的 getter 时
 3. 使用了 @dynamic 时
 4. 在 @protocol 中定义的所有属性
 5. 在 category 中定义的所有属性
 6. 重写（overridden）的属性 
 
 当你在子类中重写（overridden）了父类中的属性，你必须 使用 `@synthesize` 来手动合成ivar。

除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 `@dynamic` 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。

因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 `@synthesize` 来手动合成 ivar。

其实，`@synthesize` 语法还有一个应用场景，但是不太建议大家使用：

可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:
 
```Objective-C
@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
```



上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。



举例说明：应用场景：


 ```Objective-C

//
// .m文件
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 打开第14行和第17行中任意一行，就可编译成功

@import Foundation;

@interface CYLObject : NSObject
@property (nonatomic, copy) NSString *title;
@end

@implementation CYLObject {
    //    NSString *_title;
}

//@synthesize title = _title;

- (instancetype)init
{
    self = [super init];
    if (self) {
        _title = @"微博@iOS程序犭袁";
    }
    return self;
}

- (NSString *)title {
    return _title;
}

- (void)setTitle:(NSString *)title {
    _title = [title copy];
}

@end
 ```

结果编译器报错：
![https://github.com/ChenYilong](http://i.imgur.com/fAEGHIo.png)

当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：

 1. 要么如第14行：手动创建 ivar
 2. 要么如第17行：使用`@synthesize foo = _foo;` ，关联 @property 与 ivar。

更多信息，请戳- 》[ ***When should I use @synthesize explicitly?*** ](http://stackoverflow.com/a/19821816/3395008)


### objc使用什么机制管理对象内存？

- 通过 `retainCount` 的机制来决定对象是否需要释放。
- ~~每次 `runloop` 的时候，都会检查对象的 `retainCount`，如果 `retainCount` 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。(正解：retainCount 不可能依赖 runloop 检查。runloop 只是自动管理了一个 autoreleasepool，autoreleasepool pop 时可能会导致 retainCount 为 0 从而导致对象释放)~~
- 每次 release 时检查 retainCount 减一，当为0时候释放对象。

release 对象的各种情况如下：

一、对象成员变量

这个对象 dealloc 时候，成员变量 `objc_storeStrong(&ivar,nil)` release

二、局部变量变量的释放
分情况：

1、strong obj变量，出了作用域`{}`，就  `objc_storeStrong(obj,nil)` release 对象；

 ```C
void
objc_storeStrong(id *location, id obj)
{

id prev = *location;
if (obj == prev) {
    return;
}
objc_retain(obj);
*location = obj;
objc_release(prev);
}
 ```


2、weak obj变量，出了作用域，objc_destroyWeak 将变量（obj）的地址从weak表中删除。；

3、autorelease obj变量，交给 autoreleasePool对象管理，
（1）主动使用 `@autoreleasepool{}`，出了 `{}` 对象release
（2）不使用 `@autoreleasepool{}`，交给线程管理

①线程开启`runloop`，在每次 `kCFRunLoopBeforeWaiting` 休眠时候，执行`PoolPop`（release对象）再PoolPush，
②线程没有开启`runloop`，在线程结束时候执行 `PoolPop`（release对象）

详细讨论见： [《32. objc使用什么机制管理对象内存？ #92》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/92 ) 

### ARC通过什么方式帮助开发者管理内存？
 <p><del>编译时根据代码上下文，插入 retain/release
</del></p>
ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。

在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】

讨论区：
 [《第33题，答案可能不是很准确 #15》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/15 ) 
 
### 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）


分两种情况：手动干预释放时机、系统自动去释放。


 1. 手动干预释放时机--指定  `autoreleasepool`
 就是所谓的：当前作用域大括号结束时释放。
 2. 系统自动去释放--不手动指定 `autoreleasepool`

`__autoreleasing` 修饰的 `autorelease` 对象，是在创建好之后调用`objc_autorelease` 会被添加到最近一次创建的自动释放池中，并且autorelease对象什么时候调用release，是由RunLoop来控制的：会在当前的 runloop 休眠之前，执行pop函数、调用 release 时释放。

释放的时机总结起来，可以用下图来表示：


<p align="center"><a href="https://mp.weixin.qq.com/s/A4e5h3xgIEh6PInf1Rjqsw"><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g71mm4cx74j30kr0gngnw.jpg"></a></p>


下面对这张图进行详细的解释：


从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。

我们都知道：

`__autoreleasing` 修饰的 `autorelease` 对象，是在创建好之后调用`objc_autorelease`加入到释放池。

但是如果每次都放进应用程序的 `main.m` 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？

在一次完整的 RunLoop 休眠之前，会被销毁。

那什么时间会创建自动释放池？ RunLoop 检测到事件并启动后，就会创建自动释放池。 

~~“子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。”（表述不准确， 见 issue#82 #https://github.com/ChenYilong/iOSInterviewQuestions/issues/82）~~

从 `RunLoop` 源代码中可知，子线程默认是没有 `RunLoop` 的，如果需要在子线程开启 `RunLoop` ，则需要调用 `[NSRunLoop CurrentRunLoop]` 方法，它内部实现是先检查线程，如果发现是子线程，以懒加载的形式 创建一个子线程的 `RunLoop`。并存储在一个全局的 可变字典里。开发者在调用 `[NSRunLoop CurrentRunLoop]` 时，是系统自动创建 `RunLoop` 的，而没法手动创建。

自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。

但对于 blockOperation 和 invocationOperation 这种默认的 Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。

@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。

举一个例子: 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。

注意: 本次论述, 并不适用于 TaggedPointer 类型.

参考链接：[《黑幕背后的Autorelease》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)

拓展问题：

下面的对象 ，分别在什么地方被释放 ?

 ```Objective-C
/**
 * 下面的对象 ，分别在什么地方被释放 ?
 */
- (void)weakLifeCycleTest {
    id obj0 = @"iTeaTime(技术清谈)";
    __weak id obj1 = obj0;
    id obj2 = [NSObject new];
    __weak id obj3 = [NSObject new];
    {
        id obj4 = [NSObject new];
    }
    __autoreleasing id obj5 = [NSObject new];
    __unsafe_unretained id obj6 = self;
    NSLog(@"obj0=%@, obj1=%@, obj2=%@, obj3=%@, obj5=%@, obj6=%@", obj0, obj1, obj2, obj3, obj5, obj6);
    // Lots of code ...
}
 ```

- obj0 字符串属于常量区，不会释放 (类似的例子可以参考 [《第34题，autorelease对象的释放时机，对iOS9、10系统不适用 #90》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/90 ) )
- obj1 指向的对象在常量区，不会释放 (类似的例子可以参考 [《第34题，autorelease对象的释放时机，对iOS9、10系统不适用 #90》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/90 ) )
- obj2 没有修复符，默认为 `__strong` ，会在对象被使用结束时释放。如果下方没有使用该对象，根据编译器是否优化，可能在下一行直接销毁，最晚可以在方法结束时销毁。
- obj3 警告 “Assigning retained object to weak variable; object will be released after assignment” ，new 结束后，等号右侧对象立马被释放，左侧指针也立即销毁，下方打印也是 null
- obj4 出了最近的括号销毁
- obj5 出了最近的一个 autoreleasePool 时被释放
- obj6 类似于基本数据结构的修饰符号 assign ，不会对修饰对象的生命周期产生影响，随着self的释放，obj6也会随之释放。比如 self 被其它线程释放，那么obj6也会随之释放。

讨论区：

- [《关于第 34 题关于 NSOperation 中需要手动添加 Autorelease Pool 的部分的疑问 #25》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/25 ) 
- [《34题-36题-题目中很多对AutoreleasePool的理解都是有问题的 #112》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/112 ) 


###  BAD_ACCESS在什么情况下出现？
访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。
死循环
###  苹果是如何实现autoreleasepool的？ 

AutoreleasePool 是以 AutoreleasePoolPage 为结点的双向链表来实现的，主要通过下列三个函数完成：

 1. `objc_autoreleasepoolPush`
 2. `objc_autoreleasepoolPop`
 3. `objc_autorelease`

看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。

举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：

 
 <p align="center"><a href="https://mp.weixin.qq.com/s/A4e5h3xgIEh6PInf1Rjqsw"><img src="http://ww1.sinaimg.cn/large/006y8mN6gy1g71molq31cj30ad0iojse.jpg"></a></p>

讨论区：

- [《34题-36题-题目中很多对AutoreleasePool的理解都是有问题的 #112》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/112 ) 
