# 属性和成员变量修饰符
### weak和unsafe_unretained
```
#import "ViewController.h"
#import "MJPerson.h"
@interface ViewController ()
@end
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // ARC是LLVM编译器和Runtime系统相互协作的一个结果
    __strong MJPerson *person1;
    __weak MJPerson *person2;
    __unsafe_unretained MJPerson *person3;

    NSLog(@"111");

    {
        MJPerson *person = [[MJPerson alloc] init];
        person3 = person;//
        person2 = person;//__weak自动置为null
//        person1 = person;//离开作用域销毁，person不会被销毁，被强引用者
        int a;
        //&person,打印的是变量的地址
        //person 打印的变量指向的地址,也就是对象的地址
        NSLog(@"person对象 - %p ，person变量 - %p ，a变量 - %p",person , &person, &a);
        //__unsafe_unretained需要手动置为nil,否则坏内存访问崩溃
        person3 = nil;
    } // -[MJPerson dealloc]
    NSLog(@"222 - %@", person2); // null
    NSLog(@"222 - %@", person3); // null
}
@end
```
### 各种成员变量修饰符

```
- (void)weakLifeCycleTest {
    id obj0 = @"iTeaTime(技术清谈)";
    __weak id obj1 = obj0;
    id obj2 = [NSObject new];
    __weak id obj3 = [NSObject new]; 
    {
        id obj4 = [NSObject new];
    }
    __autoreleasing id obj5 = [NSObject new];
    __unsafe_unretained id obj6 = self;
    NSLog(@"obj0=%@, obj1=%@, obj2=%@, obj3=%@, obj5=%@, obj6=%@", obj0, obj1, obj2, obj3, obj5, obj6);
   
   //obj0=iTeaTime(技术清谈), 
   //obj1=iTeaTime(技术清谈), 
   //obj2=<NSObject: 0x6000030d01e0>, 
   //obj3=(null), 
   //obj5=<NSObject: 0x6000030d01d0>, 
   //obj6=<ViewController: 0x147f07910>

- obj0 字符串属于常量区，不会释放
- obj1 指向的对象在常量区，不会释放
- obj2 没有修复符，默认为 `__strong` ，会在对象被使用结束时释放。如果下方没有使用该对象，根据编译器是否优化，可能在下一行直接销毁，最晚可以在方法结束时销毁。
- obj3 警告 “Assigning retained object to weak variable; object will be released after assignment” ，new 结束后，等号右侧对象立马被释放，左侧指针也立即销毁，下方打印也是 null
- obj4 出了最近的括号销毁
- obj5 出了最近的一个 autoreleasePool 时被释放
- obj6 类似于基本数据结构的修饰符号 assign ，不会对修饰对象的生命周期产生影响，随着self的释放，obj6也会随之释放。比如 self 被其它线程释放，那么obj6也会随之释放。
}
```

### automic修饰符
```
#import <Foundation/Foundation.h>
@interface MJPerson : NSObject
@property (assign, nonatomic) int age;
@property (copy, atomic) NSString *name;
@property (strong, atomic) NSMutableArray *data;
@end

/*
 nonatomic和atomic
 atom：原子，不可再分割的单位
 atomic：原子性
 给属性加上atomic修饰，可以保证属性的setter和getter都是原子性操作，也就是保证setter和gette内部是线程同步的
 
 //- (void)setName:(NSString *)name
//{
//    // 加锁
//    _name = name;
//    // 解锁
//}

//- (NSString *)name
//{
// 加锁
//    return _name;
// 解锁
//}
 */
```
```
#import <Foundation/Foundation.h>
#import "MJPerson.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MJPerson *p = [[MJPerson alloc] init];
        for (int i = 0; i < 10; i++) {
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
                // 加锁
                p.data = [NSMutableArray array]; //data如果用atomic修饰，p.data = [NSMutableArray array] 是线程安全的，如果用nonautomic修饰，需要加锁
                // 解锁
            });
        }

        NSMutableArray *array = p.data; //getter是线程安全的
        //automic只能保证getter和stter安全，下面3句不是线程安全的。需要加锁
        // 加锁
        [array addObject:@"1"];
        [array addObject:@"2"];
        [array addObject:@"3"];
        // 解锁
    }
    return 0;
}
```

### weak实现原理
-   当一个对象要释放时，会自动调用`dealloc`，接下的调用轨迹是
1.`dealloc`  
2.`_objc_rootDealloc`  
3.`rootDealloc`  
4.`object_dispose`  
5.`objc_destructInstance`、`free`

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2396ef19e58d46999534ec3790971f86~tplv-k3u1fbpfcp-watermark.image?)


### 使用strong和copy可能导致数组崩溃
