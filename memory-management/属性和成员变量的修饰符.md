# 属性和成员变量修饰符

### 什么情况使用 weak 关键字，相比 assign 有什么不同？
什么情况使用 weak 关键字？
 1. 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性

 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***

不同点：
 
 1. `weak` 修饰符表明该属性定义了一种“非拥有关系” (nonowning relationship)。在为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此行为与 assign 类似，不同之处在于，在 weak 属性所指的对象遭到销毁、释放时，该属性值也会清空(nil out)。而 `assign` 的“设置方法”只会执行针对“纯量类型/基本数据类型” (scalar type，例如 CGFloat 或 
NSInteger 等)的简单赋值操作。

 2. assign 可以用非 OC 对象,而 weak 必须用于 OC 对象

其他讨论见： [《第2题 #89》]( https://github.com/ChenYilong/iOSInterviewQuestions/issues/89 ) 


### 怎么用 copy 关键字？
用途：

 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
 2. block 也经常使用 copy 关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：

  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.
  
  在 ARC 中写不写都行：
  
  在 ARC 环境下，编译器会根据情況自动将栈上的 block 复制到堆上，比如以下情况：

- block 作为函数返回值时
- 将 block 赋值给 __strong 指针时（property 的 copy 属性对应的是这一条）
- block 作为 Cocoa API 中方法名含有 using Block 的方法参数时
- block 作为 GCD API 的方法参数时

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfj47m0v1wj30s01cak0r.jpg)
  
其中， block 的 property 设置为 copy， 对应的是这一条：将 block 赋值给 __strong 指针时。

  
  
  换句话说：
  
  对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写还依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？

 ```Objective-C
 @property (nonatomic, copy) NSString *userId;

 - (instancetype)initWithUserId:(NSString *)userId {
    self = [super init];
    if (!self) {
        return nil;
    }
    _userId = [userId copy];
    return self;
 }

 ```

 ![https://github.com/ChenYilong](http://i.imgur.com/VlVKl8L.png)

下面做下解释：
 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。


> 用 `@property` 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。
 
该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***


### 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`
两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； 

第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。

比如下面的代码就会发生崩溃

 
 
```Objective-C
// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

@property (nonatomic, copy) NSMutableArray *mutableArray;
```

```Objective-C
// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];
```

接下来就会奔溃：

 
```Objective-C
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
```

第2条原因，如下：

> 该属性使用了互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。），会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。

在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。）。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。

在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。

一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的加锁机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。

因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用
 atomic 属性通常都不会有性能瓶颈。

如果对题有疑问，可参考讨论区： [《第四题 #62》](https://github.com/ChenYilong/iOSInterviewQuestions/issues/62) 




### weak和unsafe_unretained
```
#import "ViewController.h"
#import "MJPerson.h"
@interface ViewController ()
@end
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // ARC是LLVM编译器和Runtime系统相互协作的一个结果
    __strong MJPerson *person1;
    __weak MJPerson *person2;
    __unsafe_unretained MJPerson *person3;

    NSLog(@"111");

    {
        MJPerson *person = [[MJPerson alloc] init];
        person3 = person;//
        person2 = person;//__weak自动置为null
//        person1 = person;//离开作用域销毁，person不会被销毁，被强引用者
        int a;
        //&person,打印的是变量的地址
        //person 打印的变量指向的地址,也就是对象的地址
        NSLog(@"person对象 - %p ，person变量 - %p ，a变量 - %p",person , &person, &a);
        //__unsafe_unretained需要手动置为nil,否则坏内存访问崩溃
        person3 = nil;
    } // -[MJPerson dealloc]
    NSLog(@"222 - %@", person2); // null
    NSLog(@"222 - %@", person3); // null
}
@end
```
### 对象的修饰符

```
- (void)weakLifeCycleTest {
    id obj0 = @"iTeaTime(技术清谈)";
    __weak id obj1 = obj0;
    id obj2 = [NSObject new];
    __weak id obj3 = [NSObject new]; 
    {
        id obj4 = [NSObject new];
    }
    __autoreleasing id obj5 = [NSObject new];
    __unsafe_unretained id obj6 = self;
    NSLog(@"obj0=%@, obj1=%@, obj2=%@, obj3=%@, obj5=%@, obj6=%@", obj0, obj1, obj2, obj3, obj5, obj6);
   
   //obj0=iTeaTime(技术清谈), 
   //obj1=iTeaTime(技术清谈), 
   //obj2=<NSObject: 0x6000030d01e0>, 
   //obj3=(null), 
   //obj5=<NSObject: 0x6000030d01d0>, 
   //obj6=<ViewController: 0x147f07910>

- obj0 字符串属于常量区，不会释放
- obj1 指向的对象在常量区，不会释放
- obj2 没有修复符，默认为 `__strong` ，会在对象被使用结束时释放。如果下方没有使用该对象，根据编译器是否优化，可能在下一行直接销毁，最晚可以在方法结束时销毁。
- obj3 警告 “Assigning retained object to weak variable; object will be released after assignment” ，new 结束后，等号右侧对象立马被释放，左侧指针也立即销毁，下方打印也是 null
- obj4 出了最近的括号销毁
- obj5 出了最近的一个 autoreleasePool 时被释放
- obj6 类似于基本数据结构的修饰符号 assign ，不会对修饰对象的生命周期产生影响，随着self的释放，obj6也会随之释放。比如 self 被其它线程释放，那么obj6也会随之释放。
}
```

### automic
```
#import <Foundation/Foundation.h>
@interface MJPerson : NSObject
@property (assign, nonatomic) int age;
@property (copy, atomic) NSString *name;
@property (strong, atomic) NSMutableArray *data;
@end

/*
 nonatomic和atomic
 atom：原子，不可再分割的单位
 atomic：原子性
 给属性加上atomic修饰，可以保证属性的setter和getter都是原子性操作，也就是保证setter和gette内部是线程同步的
 
 //- (void)setName:(NSString *)name
//{
//    // 加锁
//    _name = name;
//    // 解锁
//}

//- (NSString *)name
//{
// 加锁
//    return _name;
// 解锁
//}
 */
```
```
#import <Foundation/Foundation.h>
#import "MJPerson.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MJPerson *p = [[MJPerson alloc] init];
        for (int i = 0; i < 10; i++) {
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
                // 加锁
                p.data = [NSMutableArray array]; //data如果用atomic修饰，p.data = [NSMutableArray array] 是线程安全的，如果用nonautomic修饰，需要加锁
                // 解锁
            });
        }

        NSMutableArray *array = p.data; //getter是线程安全的
        //automic只能保证getter和stter安全，下面3句不是线程安全的。需要加锁
        // 加锁
        [array addObject:@"1"];
        [array addObject:@"2"];
        [array addObject:@"3"];
        // 解锁
    }
    return 0;
}
```

### 错误使用strong和copy可能导致的数组问题
```
#import <Foundation/Foundation.h>
#import "MJPerson.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MJPerson *p = [[MJPerson alloc] init];
        [p array_strong_Test];
        //传入的是可变的,用strong修饰,并不会崩溃
        p.data = [NSMutableArray array];
        [p.data addObject:@"jack"];
        [p.data addObject:@"rose"];
        //传入的是可变的,用copy修饰,自动变成了不可变,会崩溃
        p.array = [NSMutableArray array];
        [p.array addObject:@"jack"];
        [p.array addObject:@"rose"];
        [p release];
    }
    return 0;
}
```
#### MJPerson
```
#import <Foundation/Foundation.h>
@interface MJPerson : NSObject
@property (copy, nonatomic) NSMutableArray *array; //NSMutableArray不应该使用copy
@property (strong, nonatomic) NSArray *data;//NSArray最好使用copy
@property (nonatomic, strong) NSArray *array2;

- (void)array_strong_Test;

@end
```

```
#import "MJPerson.h"
@implementation MJPerson

//- (void)setData:(NSArray *)data
//{
//    if (_data != data) {
//        [_data release];
//        _data = [data copy]; //如果修饰data的是copy，而传入的是可变数组，这里会强制变成不可变
//    }
//}

//NSArray用strong修饰导致数组类型会变
- (void)array_strong_Test {
    NSArray *array = @[ @1, @2, @3, @4 ];
    NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
    self.array2 = mutableArray;//赋值操作，strong修饰的话会强引用，copy修饰的话就是copy，不会被引用
    [mutableArray removeAllObjects];;
    NSLog(@"self.array2 = %@",self.array2);//array2变成了空的可变数组
    [mutableArray addObjectsFromArray:array];
    self.array2 = [mutableArray copy];//array2变成不可变数组，里面有[ @1, @2, @3, @4 ]
    [mutableArray removeAllObjects];;
    NSLog(@"self.array2 = %@",self.array2);//array2变成不可变数组，里面有[ @1, @2, @3, @4 ]
}

- (void)dealloc{
    self.data = nil;
    [super dealloc];
}
@end
```